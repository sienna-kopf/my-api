# my-api
## Overview:
Tasked with building out ReST, single-finders, multi-finders, and buisness intelligence endpoints for a simple e-commerce site.
- Ruby on Rails API
- Responses serialized adherent to JSON 1.0 industry standards
- Test Driven Development with ~100% coverage in RSpec Test Suite
- Focus on MVC design principals and ReST

## Learning Goals: 
- Expose an API
- Use serializers to format JSON responses
- Test API exposure
- Compose advanced ActiveRecord queries to analyze information stored in SQL databasese
- Write basic SQL statements without the assistance of an ORM

## Getting Started 
### Pre Built Front End test suite [Rails Driver](https://github.com/turingschool-examples/rails_driver) 
- `git clone git@github.com:turingschool-examples/rails_driver.git` 
- `cd rails_driver`
- `bundle` (if this fails, try to `bundle update` and then retry)
- `rails db:create` && `rails db:migrate`
- `bundle exec figaro install`
- In `config/application.yml` add `RAILS_ENGINE_DOMAIN: http://localhost:3000` to set up the server port. 

###  `my_api` Back End Ruby on Rails API
From the same root level as `rails_driver`:
- `git clone git@github.com:sienna-kopf/my-api.git`
- `cd my_api`
- `bundle install`

## Testing: 
The `my_api` application is fully tested using RSpec reporting ~100% test coverage determined by SimpleCov. 
To run the test suite, setup the application and run `bundle exec rspec` in the terminal. To run a specific test run `bundle exec rspec <test file path>`. To open the coverage report generated by SimpleCov run `open coverage/index.html`.

To run the front-end Test Suite, [Rails Driver](https://github.com/turingschool-examples/rails_driver), setup that applicaition and run `bundle exec rspec` in the terminal. There should be 16 passing tests and one failing test for a buisness intelligence endpoint. 

## Endpoint Use:
[Postman](https://www.postman.com/downloads/) is recommended, but any API platform that allows you to run enpoint queries with query params, headers, and a request body will do! </br>

In `my_api` run `rails s` to start the server. This will give you a port URL, something like `http://localhost:3000`, which is the main URI path for all the endpoint queries. In your API platform, the base URL will look like `http://localhost:3000/api/v1/<endpoint>` because all current endpoints are part of the first version of the API, and are therefore namespaced as such. </br>

### Example 1: 
#### Item ReST (index action (no body))

To run the `items` index endpoint, the URL in your API platform would look like `http://localhost:3000/api/v1/items` with the request method type set to `GET`.

In Postman, the setup for this endpoint looks like:
![Screen Shot 2020-10-12 at 10 39 33 PM](https://user-images.githubusercontent.com/62857073/95816258-df615080-0cdb-11eb-90af-5e4b9b1e2c6c.png)

The response for this endpoint is a JSON 1.0 standard display of all of the items seeded into the database, including name, description, unit_price, and merchant_id for each item. A sample of this response looks like:
![Screen Shot 2020-10-12 at 10 41 30 PM](https://user-images.githubusercontent.com/62857073/95816337-16cffd00-0cdc-11eb-89c4-7b5bc00e428a.png)

#### Item ReST (create action (with body)) 
To run the `items` create endpoint, the URL in your API platform would look like `http://localhost:3000/api/v1/items` with the request method type set to `POST`. For this endpoint, we also need to send a request body with the new items name, description, unit_price, and merchant_id. In Postman, we will include this information as JSON under the body tab like this:
![Screen Shot 2020-10-12 at 10 43 24 PM](https://user-images.githubusercontent.com/62857073/95816514-86de8300-0cdc-11eb-84ab-0aefce271060.png)

The response for this endpoint is a JSON 1.0 standard display of the details for the item that was just created, including name, description, unit_price, and merchant_id for each item. For this example the response looks like:
![Screen Shot 2020-10-12 at 10 44 22 PM](https://user-images.githubusercontent.com/62857073/95816516-88a84680-0cdc-11eb-97bd-63b8b59f5e70.png)

#### Merchant Relationships (merchant-items)

To run the `merchant/:id/items` merchant-items endpoint, the URL in your API platform would look like `http://localhost:3000/api/v1/merchant/:id/items` with the request method type set to `GET`. The path variable `:id` should be set to an existant merchant id in the database. In Postman, the setup for this endpoint looks like:
![Screen Shot 2020-10-12 at 10 58 41 PM](https://user-images.githubusercontent.com/62857073/95817370-7cbd8400-0cde-11eb-8ec7-0004d3947dab.png)

The response for this endpoint is a JSON 1.0 standard display of all of the items seeded into the database with that merchant as an associated foreign key, including name, description, unit_price, and merchant_id for each item. A sample of this response looks like:
![Screen Shot 2020-10-12 at 10 59 47 PM](https://user-images.githubusercontent.com/62857073/95817421-a4145100-0cde-11eb-91f1-5cc421e6e095.png)

#### Merchant ReST (delete action (with dependencies)
To run the `merchants` delete endpoint, the URL in your API platform would look like `http://localhost:3000/api/v1/merchants/:id` with the request method type set to `DELETE`. The path variable `:id` must be set to an existant merchant in the database. In Postman, this setup looks like: 
![Screen Shot 2020-10-12 at 10 48 26 PM](https://user-images.githubusercontent.com/62857073/95816784-23088a00-0cdd-11eb-9d3a-195d1822adb0.png)

The response for this endpoint sends a 204 HTTP status code:
![Screen Shot 2020-10-12 at 10 49 34 PM](https://user-images.githubusercontent.com/62857073/95816819-36b3f080-0cdd-11eb-9e9a-2637cadec55c.png)

The deletion of a `merchant` from the database triggers a series of dependecy deletes for any `invoices`, `invoiceItems`, `payments`, and `items` associated in a dependent fashion to that `merchant`. 

This can be demonstrated by establishing that a `merchant` has many items through the `merchants/:id/items` endpoint. This might look like: 
![Screen Shot 2020-10-12 at 10 53 39 PM](https://user-images.githubusercontent.com/62857073/95817192-205a6480-0cde-11eb-9a55-42e13aa05e5f.png)

Then, when that merchant is deleted, a search for any of the items displayed under the merchant items endpoint display a 204 no content error. The same is true for other associated objects such as `invoices`, `payments`, and `invoiceItems`:
![Screen Shot 2020-10-12 at 10 55 15 PM](https://user-images.githubusercontent.com/62857073/95817195-20f2fb00-0cde-11eb-83d9-4288cb0d2ea5.png)

#### Item Single Finder (name) 
To run the `items/find` item single-finder endpoint, the URL in your API platform would look like `http://localhost:3000/api/v1/items/find` with the request method type set to `GET`. A query parameter should be included based on the attributes of the resource, for item name, description, unit_price, merchant_id, or created_at / updated_at date. This parameter would look something like "name=distinct" or "unit_price=42.91". Name and description are case insensitive character inclusion searches so if the name of an item is "Item Distinctio" a query for "Distinctio", "distinctio", "distinct" etc will all work. `unit_price`, `created_at` and `updated_at` dates, and `merchant_id` are all exact finders, and much be matched exactly for an appropriate response. In Postman, the setup for this endpoint might look something like:
![Screen Shot 2020-10-12 at 11 15 16 PM](https://user-images.githubusercontent.com/62857073/95818319-d3c45880-0ce0-11eb-8fa0-6354404a05fc.png)

The response for this example is a JSON 1.0 standard display of a single item in the database that matches the search. In this example, the response looks like:
![Screen Shot 2020-10-12 at 11 16 49 PM](https://user-images.githubusercontent.com/62857073/95818402-05d5ba80-0ce1-11eb-8ac9-7eaa2eb72138.png)

#### Merchant Multi-Finder (name) 
To run the `merchants/find_all` merchant multi-finder endpoint, the URL in your API platform would look like `http://localhost:3000/api/v1/merchants/find_all` with the request method type set to `GET`. A query parameter should be included based on the attributes of the resource, for merchants the searchable attributes are name and created_at/updated_at date. This parameter would look something like "name=sons". Name is a case insensitive character inclusion search so if the name of an merchant is "Willms and Sons" a query for "Sons", "sons", "son" etc will all work. `created_at` and `updated_at` dates are exact finders, and much be matched exactly for an appropriate response. In Postman, the setup for this endpoint might look something like:
![Screen Shot 2020-10-12 at 11 20 49 PM](https://user-images.githubusercontent.com/62857073/95818682-aa57fc80-0ce1-11eb-9292-a9aa7ea3cf71.png)

The response for this example is a JSON 1.0 standard display of all merchants in the database that match the search. In this example, a sample of the response looks like:
![Screen Shot 2020-10-12 at 11 21 26 PM](https://user-images.githubusercontent.com/62857073/95818691-ae841a00-0ce1-11eb-9244-8df74ae17c72.png)

### Buisness Intelligence Endpoints 
#### Merchant Total Revenue 
To run the `merchants/:id/revenue` merchant revenue endpoint, the URL in your API platform would look like `http://localhost:3000/api/v1/merchants/:id/revenue` with the request method type set to `GET`. The path varible `:id` should be set to the id of a merchant in the database. In Postman, the setup for this endpoint looks like:
![Screen Shot 2020-10-12 at 11 24 17 PM](https://user-images.githubusercontent.com/62857073/95818853-10448400-0ce2-11eb-9722-a6473aca5498.png)

The response for this endpoint is a JSON 1.0 standard display of all of the revenue for that particular merchant. In this example, the repsonse looks like:
![Screen Shot 2020-10-12 at 11 25 33 PM](https://user-images.githubusercontent.com/62857073/95818946-3e29c880-0ce2-11eb-861a-0e34b69198b8.png)

The ActiveRecord Query required for this endpoint involved joining a merchants `invoices` through the `invoiceItems` table all the way to `payments` in order to select the aggregate revenue of only successfully paid for and shipped items. The method that handles this ActiveRecord query and creation of a Revenue object to be serialized looks like: 
![Screen Shot 2020-10-12 at 11 26 55 PM](https://user-images.githubusercontent.com/62857073/95819215-b7292000-0ce2-11eb-9bc6-fdcd91df89dc.png)

#### Merchants with Most Revenue 
To run the `merchants/most_revenue` merchants with most revenue endpoint, the URL in your API platform would look like `http://localhost:3000/api/v1/merchants/most_revenue` with the request method type set to `GET`. The query parameter `quantity` should be set to the number of merchants desired in the return -- for example "quantity=2". In Postman, the setup for this endpoint looks like:
![Screen Shot 2020-10-12 at 11 31 35 PM](https://user-images.githubusercontent.com/62857073/95819416-30c10e00-0ce3-11eb-804f-f50a3671e5f9.png)

The response for this endpoint is a JSON 1.0 standard display of the top x merchants by total revenue. In this example, the repsonse looks like:
![Screen Shot 2020-10-12 at 11 32 21 PM](https://user-images.githubusercontent.com/62857073/95819422-31f23b00-0ce3-11eb-98a0-e448903be353.png)

The ActiveRecord Query required for this endpoint involved joining a merchants `invoices` through the `invoiceItems` table all the way to `payments` in order to select the merchants data along side aggregate revenue of only successfully paid for and shipped items. The list of merchants was then limited by the `quantity` query param. The method that handles this ActiveRecord query looks like: 
![Screen Shot 2020-10-12 at 11 33 05 PM](https://user-images.githubusercontent.com/62857073/95819461-4afaec00-0ce3-11eb-82b2-cd574c2190b9.png)

#### Merchants with Most Items 
To run the `merchants/most_items` merchants with most items endpoint, the URL in your API platform would look like `http://localhost:3000/api/v1/merchants/most_items` with the request method type set to `GET`. The query parameter `quantity` should be set to the number of merchants desired in the return -- for example "quantity=2". In Postman, the setup for this endpoint looks like:
![Screen Shot 2020-10-12 at 11 36 12 PM](https://user-images.githubusercontent.com/62857073/95819653-c197e980-0ce3-11eb-8b5d-b923da09e262.png)

The response for this endpoint is a JSON 1.0 standard display of the top x merchants by item count. In this example, the repsonse looks like:
![Screen Shot 2020-10-12 at 11 36 27 PM](https://user-images.githubusercontent.com/62857073/95819659-c361ad00-0ce3-11eb-8202-b0d0ab7e6fdb.png)

The ActiveRecord Query required for this endpoint involved joining a merchants `invoices` through the `invoiceItems` table all the way to `payments` in order to select the merchants data along side the aggregate total invoiceItems of only successful payments for and shipped invoices. The list of merchants was then limited by the `quantity` query param. The method that handles this ActiveRecord query looks like: 
![Screen Shot 2020-10-12 at 11 35 29 PM](https://user-images.githubusercontent.com/62857073/95819600-a1682a80-0ce3-11eb-9296-ab8892c2a825.png)

### Screen Cast of all Endpoints:

Below a screen cast is attached running through all the endpoints of the project:
[<img width="1077" alt="Screen Shot 2020-10-12 at 11 47 26 PM" src="https://user-images.githubusercontent.com/62857073/95820424-4d5e4580-0ce5-11eb-96bb-e81e4d3c7805.png">](https://vimeo.com/user124948662/review/467615357/4883298a4a)

## Tools:
- FastJsonAPI
- Faker
- Shoulda-Matchers
- Factory Bot Rails
- RSpec
- Pry
- SimpleCov
- PostgreSQL

## Authors:

[Sienna Kopf](https://github.com/sienna-kopf)
